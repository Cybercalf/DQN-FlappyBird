## 游戏部分

原始游戏画面宽288px高512px

背景图片是纯黑的，为了减小对卷积神经网络的干扰

帧率30FPS

因为玩家可能在任何一帧选择拍动鸟翅膀，所以游戏每一帧都要传入一个action参数，在每一帧对得分、是否发生碰撞、游戏是否结束、reward等参数都要做计算

对于任意一帧，游戏的处理步骤：
- 初始化这一帧的奖励（reward）和游戏中止的信号变量（terminal）
- 检查给定的action是否合法，这个检查和action的结构有关
- 如果小鸟拍动翅膀，更新小鸟在Y轴上的速度
- 检查这一帧小鸟是不是越过了一对水管。如果是，游戏分数+1，reward变成1
- 改变playerIndex（小鸟有拍打翅膀的动画，这个playerIndex说明了小鸟此时的图片是哪一张。而且根据作者判断碰撞上的优化算法，这个playerIndex在后面判断碰撞时也会用到）
- 根据小鸟的速度，更新小鸟在Y轴上的位置。规定小鸟不会飞出屏幕，碰到屏幕最上方不算做失败。
- 水管向左移动
- 如果最左边的水管快要碰到屏幕左侧，在水管列表中再添加一对水管
- 如果最左边的水管从屏幕左侧移出了屏幕，移除这一对水管
- 检查更新位置之后小鸟和水管是否发生了碰撞。如果是，游戏中止（terminal=True），reward变成-5，重置游戏
- 将各图片绘制在画布上（包括游戏分数）
- 把这一帧的游戏画面、reward、terminal作为参数返回（游戏画面是卷积神经网络的输入成分）

作者把绘制分数、检测小鸟和水管的碰撞、生成一对新的水管封装成了其他函数。小鸟碰到地板或者碰到水管都算作失败。

作者通过在导入图片时为图片添加了透明度选项，为小鸟和水管的图片生成了hitmask（也就是不透明的部分，也就是人能看到的部分），用hitmask来检测碰撞，而不是简单检测图片矩形是否碰撞，这样在一定程度上更加符合人的直觉（提高真实性）。

如果直接用矩形检测是否发生碰撞，那么playerIndex就没有实际意义了，而且小鸟是否切换图片都不影响训练，为了方便可以先用矩形检测

## DQN部分

输出的action：一个数组，只有**2**种合法的可能：`[0, 1]`和`[1, 0]`，小鸟不拍动翅膀就是`input_actions[0] == 1`，拍动翅膀就是`input_actions[1] == 1`，只有`sum(input_actions) == 1`才合法